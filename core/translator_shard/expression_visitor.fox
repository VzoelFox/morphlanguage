# core/translator_shard/expression_visitor.fox
# Visitor untuk ekspresi

ambil_semua "core/morph_t.fox" sebagai T
ambil_semua "core/absolute_syntax_morph.fox" sebagai AST
ambil_semua "core/translator_shard/runtime.fox" sebagai RT
ambil_sebagian tambah dari "core/cotc(stdlib)/core.fox"

kelas ExpressionVisitor maka

    asink fungsi kunjungi_Tunggu(node) maka
        biar awaitable = tunggu ini._evaluasi(node.ekspresi)
        # Di Morph self-hosted, kita asumsikan awaitable adalah sesuatu yang bisa di-'tunggu'
        # Implementasi detail tergantung VM/Runtime yang menjalankan kode ini.
        kembali tunggu awaitable
    akhir

    asink fungsi kunjungi_AmbilProperti(node) maka
        biar objek = tunggu ini._evaluasi(node.objek)

        # Cek FFI (Stubbed for now, as Morph introspection might differ)
        # Jika objek adalah module/objek eksternal...

        jika jenis(objek) == RT.MorphInstance maka
            biar adalah_akses_internal = salah # jenis(node.objek) == AST.Ini (perlu operator jenis/isinstance yang benar)
            # Simulasi isinstance AST.Ini
            # Kita belum tentu punya akses ke AST.Ini sebagai runtime type check di sini tanpa import AST yang benar
            # Asumsi 'jenis' mengembalikan referensi kelas.

            # TODO: Implementasi cek jenis node.objek

            kembali objek.dapatkan(node.nama, adalah_akses_internal)
        akhir

        # Default/Fallback (FFI atau error)
        lemparkan RT.KesalahanTipe(node.nama, "Hanya instance kelas yang memiliki properti (FFI belum diimplementasikan penuh).")
    akhir

    asink fungsi kunjungi_AturProperti(node) maka
        biar adalah_akses_internal = salah # TODO: Cek AST.Ini
        biar objek = tunggu ini._evaluasi(node.objek)

        jika jenis(objek) != RT.MorphInstance maka
            lemparkan RT.KesalahanTipe(node.nama, "Hanya instance dari kelas yang dapat diatur propertinya.")
        akhir

        biar nilai = tunggu ini._evaluasi(node.nilai)
        objek.tetapkan(node.nama, nilai, adalah_akses_internal)
        kembali nilai
    akhir

    asink fungsi kunjungi_Ini(node) maka
        kembali ini.lingkungan.dapatkan(node.kata_kunci)
    akhir

    asink fungsi kunjungi_Induk(node) maka
        biar superkelas = ini.lingkungan.dapatkan(node.kata_kunci)
        biar tok_ini = T.Token(T.NAMA, "ini", node.kata_kunci.baris, node.kata_kunci.kolom)
        biar instance = ini.lingkungan.dapatkan(tok_ini)

        biar metode = superkelas.cari_metode(node.metode.nilai)
        jika metode == nil maka
            lemparkan RT.KesalahanRuntime(node.metode, "Metode tidak ditemukan di superkelas.")
        akhir

        kembali metode.bind(instance)
    akhir

    asink fungsi kunjungi_Kamus(node) maka
        biar kamus = {}
        # node.pasangan adalah list of tuple/list [kunci, nilai]
        biar i = 0
        selama i < panjang(node.pasangan) maka
            biar pair = node.pasangan[i]
            biar kunci = tunggu ini._evaluasi(pair[0])
            biar nilai = tunggu ini._evaluasi(pair[1])

            # Cek tipe kunci string?
            kamus[kunci] = nilai
            i = i + 1
        akhir
        kembali kamus
    akhir

    asink fungsi kunjungi_Daftar(node) maka
        biar hasil = []
        biar i = 0
        selama i < panjang(node.elemen) maka
            biar val = tunggu ini._evaluasi(node.elemen[i])
            tambah(hasil, val)
            i = i + 1
        akhir
        kembali hasil
    akhir

    asink fungsi kunjungi_Akses(node) maka
        biar objek = tunggu ini._evaluasi(node.objek)
        biar kunci = tunggu ini._evaluasi(node.kunci)

        # Asumsi tipe List dan String didukung native
        # Cek tipe (list/str vs dict)

        # Implementasi sederhana akses indeks/kunci
        # Perlu error handling
        kembali objek[kunci]
    akhir

    asink fungsi kunjungi_Ambil(node) maka
        biar prompt_str = ""
        jika node.prompt != nil maka
            biar p = tunggu ini._evaluasi(node.prompt)
            prompt_str = ini._ke_string(p)
        akhir

        # Panggil fungsi native input (asumsi ada di global/FFI)
        # kembali input(prompt_str)
        kembali nil # Placeholder
    akhir

    asink fungsi kunjungi_PanggilFungsi(node) maka
        biar callee = tunggu ini._evaluasi(node.callee)

        # Stack check logic (recursion limit)

        biar argumen = []
        biar i = 0
        selama i < panjang(node.argumen) maka
            biar val = tunggu ini._evaluasi(node.argumen[i])
            tambah(argumen, val)
            i = i + 1
        akhir

        jika jenis(callee) == RT.MorphKelas maka
            kembali tunggu callee.panggil(ini, node)
        lainjika jenis(callee) == RT.Fungsi atau jenis(callee) == RT.FungsiAsink maka
            kembali tunggu callee.panggil_metode(ini, argumen, node.token)
        lainjika jenis(callee) == RT.KonstruktorVarian maka
            kembali callee.panggil(argumen, node.token)
        lainjika jenis(callee) == RT.FungsiBawaan atau jenis(callee) == RT.FungsiBawaanAsink maka
            kembali tunggu callee.panggil(argumen)
        akhir

        lemparkan RT.KesalahanTipe(node.token, "Objek tidak bisa dipanggil.")
    akhir

    asink fungsi kunjungi_Identitas(node) maka
        kembali ini.lingkungan.dapatkan(node.token)
    akhir

    asink fungsi kunjungi_Konstanta(node) maka
        kembali node.nilai
    akhir

    asink fungsi kunjungi_FoxUnary(node) maka
        biar kanan = tunggu ini._evaluasi(node.kanan)
        jika node.op.tipe == T.KURANG maka
            # Cek tipe angka
            kembali 0 - kanan
        lainjika node.op.tipe == T.TIDAK maka
            kembali tidak ini._apakah_benar(kanan)
        akhir
        kembali nil
    akhir

    asink fungsi kunjungi_FoxBinary(node) maka
        biar op_tipe = node.op.tipe

        jika op_tipe == T.DAN maka
            biar kiri = tunggu ini._evaluasi(node.kiri)
            jika tidak ini._apakah_benar(kiri) maka kembali salah akhir
            biar kanan = tunggu ini._evaluasi(node.kanan)
            kembali ini._apakah_benar(kanan)
        akhir

        jika op_tipe == T.ATAU maka
            biar kiri = tunggu ini._evaluasi(node.kiri)
            jika ini._apakah_benar(kiri) maka kembali kiri akhir
            kembali tunggu ini._evaluasi(node.kanan)
        akhir

        biar kiri = tunggu ini._evaluasi(node.kiri)
        biar kanan = tunggu ini._evaluasi(node.kanan)

        jika op_tipe == T.TAMBAH maka kembali kiri + kanan
        lainjika op_tipe == T.KURANG maka kembali kiri - kanan
        lainjika op_tipe == T.KALI maka kembali kiri * kanan
        lainjika op_tipe == T.BAGI maka kembali kiri / kanan
        lainjika op_tipe == T.MODULO maka kembali kiri % kanan
        # Pangkat ^ mungkin butuh fungsi pow() atau operator khusus

        lainjika op_tipe == T.LEBIH_DARI maka kembali kiri > kanan
        lainjika op_tipe == T.KURANG_DARI maka kembali kiri < kanan
        lainjika op_tipe == T.LEBIH_SAMA maka kembali kiri >= kanan
        lainjika op_tipe == T.KURANG_SAMA maka kembali kiri <= kanan
        lainjika op_tipe == T.SAMA_DENGAN maka kembali kiri == kanan
        lainjika op_tipe == T.TIDAK_SAMA maka kembali kiri != kanan

        kembali nil
    akhir

akhir
