# core/translator_shard/system_visitor.fox
# Visitor untuk sistem (modul, kelas, tipe)

ambil_semua "../morph_t.fox" sebagai T
ambil_semua "../absolute_syntax_morph.fox" sebagai AST
ambil_semua "runtime.fox" sebagai RT
ambil_semua "statement_visitor.fox"
ambil_sebagian tambah, panjang, tipe_objek dari "../cotc(stdlib)/core.fox"

kelas SystemVisitor warisi StatementVisitor maka

    asink fungsi kunjungi_Kelas(node) maka
        biar superkelas = nil
        jika node.superkelas != nil maka
            ubah superkelas = tunggu ini._evaluasi(node.superkelas)
            jika tipe_objek(superkelas) != RT.MorphKelas maka
                lemparkan RT.KesalahanTipe(node.superkelas.token, "Superkelas harus berupa sebuah kelas.")
            akhir
        akhir

        ini.lingkungan.definisi(node.nama.nilai, nil)
        biar lingkungan_kelas = ini.lingkungan
        jika superkelas != nil maka
            ubah lingkungan_kelas = RT.Lingkungan(ini.lingkungan)
            lingkungan_kelas.definisi("induk", superkelas)
        akhir

        biar metode = {}
        biar i = 0
        selama i < panjang(node.metode) maka
            biar metode_node = node.metode[i]
            biar adalah_inisiasi = (metode_node.nama.nilai == "inisiasi")

            biar fungsi_obj = nil
            jika tipe_objek(metode_node) == AST.FungsiAsinkDeklarasi maka
                ubah fungsi_obj = RT.FungsiAsink(metode_node, lingkungan_kelas, adalah_inisiasi)
            lain
                ubah fungsi_obj = RT.Fungsi(metode_node, lingkungan_kelas, adalah_inisiasi)
            akhir

            ubah metode[metode_node.nama.nilai] = fungsi_obj
            ubah i = i + 1
        akhir

        biar kelas_obj = RT.MorphKelas(node.nama.nilai, superkelas, metode)
        ini.lingkungan.tetapkan(node.nama, kelas_obj)
    akhir

    asink fungsi kunjungi_TipeDeklarasi(node) maka
        biar nama_tipe = node.nama.nilai
        biar tipe_varian = RT.TipeVarian(nama_tipe)
        ini.lingkungan.definisi(nama_tipe, tipe_varian)

        biar i = 0
        selama i < panjang(node.daftar_varian) maka
            biar varian_node = node.daftar_varian[i]
            biar nama_varian = varian_node.nama.nilai
            biar aritas = panjang(varian_node.parameter)

            biar konstruktor = RT.KonstruktorVarian(nama_varian, aritas)
            ubah tipe_varian.konstruktor[nama_varian] = konstruktor

            ini.lingkungan.definisi(nama_varian, konstruktor)
            ubah i = i + 1
        akhir
    akhir

    asink fungsi kunjungi_FungsiDeklarasi(node) maka
        biar fungsi_obj = RT.Fungsi(node, ini.lingkungan)
        ini.lingkungan.definisi(node.nama.nilai, fungsi_obj)
    akhir

    asink fungsi kunjungi_FungsiAsinkDeklarasi(node) maka
        biar fungsi_obj = RT.FungsiAsink(node, ini.lingkungan)
        ini.lingkungan.definisi(node.nama.nilai, fungsi_obj)
    akhir

    asink fungsi kunjungi_AmbilSemua(node) maka
        biar exports = tunggu ini.module_loader.load_module(node.path_file, ini.current_file)

        jika node.alias != nil maka
            ini.lingkungan.definisi(node.alias.nilai, exports)
        lain
            # TODO: Implementasi iterasi dict yang benar
            tulis("Peringatan: Iterasi exports di AmbilSemua belum didukung sepenuhnya.")
        akhir
    akhir

    asink fungsi kunjungi_AmbilSebagian(node) maka
        biar exports = tunggu ini.module_loader.load_module(node.path_file, ini.current_file)

        biar i = 0
        selama i < panjang(node.daftar_simbol) maka
            biar simbol_token = node.daftar_simbol[i]
            biar nama = simbol_token.nilai

            jika tidak exports.punya(nama) maka
                lemparkan RT.KesalahanNama(simbol_token, "Simbol tidak ditemukan di modul.")
            akhir

            ini.lingkungan.definisi(nama, exports[nama])
            ubah i = i + 1
        akhir
    akhir

    asink fungsi kunjungi_Pinjam(node) maka
        biar module_path = node.path_file.nilai
        biar alias = nil
        jika node.alias != nil maka
            ubah alias = node.alias.nilai
        akhir

        jika alias == nil maka
            lemparkan RT.KesalahanRuntime(node.path_file, "FFI import harus pakai alias.")
        akhir

        biar py_module = ini.ffi_bridge.import_module(module_path, node.path_file)
        ini.lingkungan.definisi(alias, py_module)
    akhir

akhir
